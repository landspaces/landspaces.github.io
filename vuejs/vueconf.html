<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>vue</title>
  <script src="./assets/vue.js"></script>
</head>
<body>
  <!-- 根组件app  -->
	<div id="compile"></div>
	<div id="app">
    <message ref="rootdom"></message>
    <message-a></message-a>
    <message-c></message-c>
  </div>
  <div class="rootApi"></div>

<script>
//////////////////////////////////////////
//全局配置
//////////////////////////////////////////

// 1.取消 Vue 所有的日志与警告
    Vue.config.silent = false;

// 2.自定义合并策略的选项
    Vue.config.optionMergeStrategies._my_option = function (parent, child, vm) {
      return child + 1
    }
    const Profile = Vue.extend({
      _my_option: 1
    })
    // Profile.options._my_option = 2

// 3.配置是否允许 vue-devtools 检查代码
    Vue.config.devtools = false
    /*
      // 开发版本默认为 true，生产版本默认为 false。
      // 生产版本设为 true 可以启用检查。
      // 务必在加载 Vue 之后，立即同步设置以下内容
    */

// 4.指定组件的渲染和观察期间未捕获错误的处理函数。这个处理函数被调用时，可获取错误信息和 Vue 实例。
    Vue.config.errorHandler = function (err, vm, info) {
      // handle error
      // `info` 是 Vue 特定的错误信息，比如错误所在的生命周期钩子
      // 只在 2.2.0+ 可用
    }

// 5.为 Vue 的运行时警告赋予一个自定义处理函数。注意这只会在开发者环境下生效，在生产环境下它会被忽略。
    Vue.config.warnHandler = function (msg, vm, trace) {
      // `trace` 是组件的继承关系追踪
    }

// 6.使 Vue 忽略在 Vue 之外的自定义元素
    Vue.config.ignoredElements = [
      'my-custom-web-component',
      'another-web-component',
      // 用一个 `RegExp` 忽略所有“ion-”开头的元素
      // 仅在 2.5+ 支持
    ]

// 7.给 v-on 自定义键位别名。
    // <input type="text" @keyup.media-play-pause="method">
    Vue.config.keyCodes = {
      v: 86,
      f1: 112,
      // camelCase 不可用
      mediaPlayPause: 179,
      // 取而代之的是 kebab-case 且用双引号括起来
      "media-play-pause": 179,
      up: [38, 87]
    }
// 8.设置为 true 以在浏览器开发工具的性能/时间线面板中启用对组件初始化、编译、渲染和打补丁的性能追踪
    // 只适用于开发模式和支持 performance.mark API 的浏览器上。
    Vue.config.performance = false
  
// 9.设置为 false 以阻止 vue 在启动时生成生产提示。
    Vue.config.productionTip = false

////////////////////////////////////////////////////////////////////////////////////
// 数据准备
////////////////////////////////////////////////////////////////////////////////////
  // 用来继承的全局组件
  let ComponentA = {
    template: '<div>继承的全局组件</div>',
    data:()=>{
      return {}
    }
  }
  // 周期挂载组件
  let ComponentB = {
    template: '<div>周期挂载的组件,我在rootapi根结点</div>',
    data:()=>{
      return {}
    }
  }
  // 声明局部组件
  let ComponentC = {
    template: '<div>局部组件</div>',
    data:()=>{
      return {}
    }
  }
  // mixins
  let mixin = {
    created: function () {console.log('声明mixin')}
  }
  // 声明data
  let data = {
    name:'李狗蛋',
    compile:'vue.compile生成的,渲染在compile根结点',
    colors:['red','blue'],
    objs:{
      class:'1',
      planid:'2'
    }
  }
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////// 数据准备完毕
////////////////////////////////////////////////////////////////////////////////////
// 全局API
////////////////////////////////////////////////////////////////////////////////////

// Vue.version
  // 细节：提供字符串形式的 Vue 安装版本号。这对社区的插件和组件来说非常有用，你可以根据不同的版本号采取不同的策略。
  var version = Number(Vue.version.split('.')[0])
  if (version === 2) {
    // Vue v2.x.x
  } else if (version === 1) {
    // Vue v1.x.x
  } else {
    // Unsupported versions of Vue
  }

// Vue.use( plugin )
  // 该方法需要在调用 new Vue() 之前被调用。
  // 当 install 方法被同一个插件多次调用，插件将只会被安装一次。
  // Vue.use(element)

// 注册全局自定义指令
  Vue.directive('bgcolor', {
      inserted: function (el , binding) {
        console.log(el,binding);
        el.style.backgroundColor = binding.value;
      }
    }
  )
  
// 全局注册一个混入，影响注册之后所有创建的每个 Vue 实例。
  // 插件作者可以使用混入，向组件注入自定义的行为。不推荐在应用代码中使用
  Vue.mixin({
    created: function () {
      console.log('全局mixin');
      var myOption = this.$options.myOption
      if (myOption) {
        console.log(myOption)
      }
    }
  })

// 注册全局组件
  Vue.component('message', {
    template: '<div>真正的全局组件</div>',
    data:()=>{
      return {}
    }
  });
// 继承注册全局组件
  Vue.component('messageA', Vue.extend(ComponentA));
  let projects = Vue.component('messageB', Vue.extend(ComponentB));

// 返回组件构造器
  let MyComponent = Vue.component('message')
  console.log(MyComponent);

// 向响应式对象中添加一个 property，并确保这个新 property 同样是响应式的，且触发视图更新。
  let objarr = []
  let keyorindex = 0
  let value  = '222'
  Vue.set(objarr,keyorindex,value)
  Vue.delete(objarr,keyorindex)

// 获取更新后的dom
  Vue.nextTick(function () {
    // DOM 更新了
  })

// 注册或获取全局过滤器
  Vue.filter('my-filter', function (value) {
    // 返回处理后的值
  })
  // getter，可以返回已注册的过滤器
  var myFilter = Vue.filter('my-filter')


// Vue.observable( object )
  // 让一个对象可响应。Vue 内部会用它来处理 data 函数返回的对象。
  // 返回的对象可以直接用于渲染函数和计算属性内，并且会在发生变更时触发相应的更新
  // 也可以作为最小化的跨组件状态存储器，用于简单的场景：
  // 参考https://cn.vuejs.org/v2/guide/reactivity.html 深入响应原理
  const state = Vue.observable({ count: 0 })
  const Demo = {
    render(h) {
      return h('button', {
        on: { click: () => { state.count++ }}
      }, `count is: ${state.count}`)
    }
  }

// Vue.compile( template )
  // 将一个模板字符串编译成 render 函数。只在完整版时可用。
  // 参考 渲染函数 https://cn.vuejs.org/v2/guide/render-function.html
  var compileData = Vue.compile(`<div><span v-bgcolor='colors[0]'></span><span>{{ compile }}</span></div>`)
  new Vue({
    el:'#compile',
    data:data, // 全局data是对象,组件内data是函数
    // compile 的render
    render: compileData.render,
    staticRenderFns: compileData.staticRenderFns,
  })
  
////////////////////////////////////////////////////////////////////////////////////
// 渲染到根节点和局部api
////////////////////////////////////////////////////////////////////////////////////
  let vm = new Vue({
    mixins:[mixin],
    el:'#app',
    data:data, // 全局data是对象,组件内data是函数
    // 局部自定义指令
    directives: {
      bgtops:{
        inserted: function (el,binding) {
          el.style.backgroundColor = binding.value;
        }
      }
    },
    // 局部组件
    components:{
      'message-c': ComponentC,
    },
    // 局部过滤
    filters:{},
    methods:{}
  })

//////////////////////////////////////////
// vue 实例属性
//////////////////////////////////////////
  // vue 实例
  console.log(vm);
  console.log(vm.$root); // 当前组件树的根 Vue 实例 , 如果当前实例没有父实例，此实例将会是其自己
  console.log(vm.$isServer); // ->false 判断当前vue实例是否运行于服务器
  console.log(vm.$el === document.getElementById('app'));// -> true
  console.log(vm.$data === data);// -> true
  console.log(vm.name === data.name);// -> true
  console.log(vm.$refs);// -> true
// 	vm.$attrs
// 		可以通过 v-bind="$attrs" 传入内部组件。
// 	vm.$props
// 		当前组件接收到的 props 对象
// 	vm.$parent
// 		父实例，如果当前实例有的话
// 	vm.$children
// 		当前实例的直接子组件。需要注意 $children 并不保证顺序，也不是响应式的
// 	vm.$slots
// 		请注意插槽不是响应性的,在使用渲染函数书写一个组件时，访问 vm.$slots 最有帮助
// 	vm.$scopedSlots
// 		访问作用域插槽
// 	vm.$isServer
// 		判断当前vue实例是否运行于服务器
// 		参考：服务端渲染
// 	vm.$listeners
// 		包含了父作用域中的不含 .native 修饰器的v-on 事件监听器
// 可以通过 v-on="$listeners" 传入内部组件

////////////////////////////////////////////////////////////////////////////////////
// vue 方法数据
////////////////////////////////////////////////////////////////////////////////////
vm.$watch(vm.objs, (news,olds)=>{
  console.log(news,olds);
})
// 	vm.$set
// 		这是全局 Vue.set 的别名
// 	vm.$delete
// 		这是全局 Vue.delete 的别名
vm.$set(vm.colors,0,'pink');
vm.objs.class = '22';
vm.$delete(vm.colors,1);
console.log(vm.colors);
// vm.$watch
// 		监听方法
// 	vm.$emit
// 		触发当前实例上的事件。附加参数都会传给监听器回调
// 	vm.$on
// 		监听当前实例上的自定义事件,由 vm.$emit 触发
// 		vm.$on('test', function (msg) { console.log(msg) })
// 		vm.$emit('test', 'hi')
// 	vm.$once
// 		监听一个自定义事件，但是只触发一次,随即移除
// 	vm.$off
// 移除自定义事件监听器

////////////////////////////////////////////////////////////////////////////////////
// vue 生命周期
////////////////////////////////////////////////////////////////////////////////////
// vm.$mount
  // 	如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素。
  // 	可以使用 vm.$mount() 手动地挂载一个未挂载的实例
  // 生命周期方式 挂载继承的局部组件
  new projects().$mount('.rootApi');
// 	vm.$forceUpdate
  // 		迫使 Vue 实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。
  // 	vm.$nextTick
  // 		将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新。它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上。
  vm.$forceUpdate()
  // 	vm.$destroy
  // 完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器。
  



</script>
</body>
</html>