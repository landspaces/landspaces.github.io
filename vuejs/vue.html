<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>vue</title>
  <script src="./assets/static/vue.js"></script>
  <style>
    #app{
      height: 100px;
      background-color: #ccc;
    }
  </style>
</head>
<body>
  <!-- 根组件app  -->
	<div id="app">
    <message-global ref="ref_global"></message-global>
    <message-a></message-a>
    <limit-component></limit-component>
  </div>
  <div id="compile"></div>
  <div class="rootApi"></div>

<script>
////////////////////////////////////////////////////////////////////////////////////
// 全局API
////////////////////////////////////////////////////////////////////////////////////
  // 局部mixin
  let mymixin = {
    template:`<span>局部mymixin</span>`,
    created: function () {
      
    }
  }
// 全局注册一个混入，影响注册之后所有创建的每个 Vue 实例。// 插件作者可以使用混入，向组件注入自定义的行为。不推荐在应用代码中使用
// 使用全局或者局部mixins影响了#app节点渲染。全局组件和局部组件也不生效了
  // Vue.mixin({
  //   template: '<div>真正的全局mixin</div>',
  //   created: function () {
  //     var myOption = this.$options.myOption
  //     if (myOption) {
  //       console.log(myOption)
  //     }
  //   }
  // })
// 注册全局自定义指令bgcolor
  Vue.directive('bgcolor', {
      inserted: function (el , binding) {
        console.log('注册全局自定义指令',el,binding);
        el.style.backgroundColor = binding.value;
      }
    }
  )
  // 获取全局指令
  let myDirective = Vue.directive('bgcolor')
  // 将一个模板字符串编译成 render 函数。只在完整版时可用。// Vue.compile( template )
  // 参考 渲染函数 https://cn.vuejs.org/v2/guide/render-function.html
  // 声明data
  let data = {
    name:'李狗蛋',
    compile:'vue.compile生成的,渲染在compile根结点',
    colors:['red','blue']
  }
  let compileData = Vue.compile(`<div><span v-bgcolor='colors[0]'>compile加自定义指令</span><span>{{ compile }}</span></div>`)
  new Vue({
    el:'#compile',
    data:data, // 全局data是对象,组件内data是函数
    render: compileData.render,// compile 的render
    staticRenderFns: compileData.staticRenderFns,
  })

// 注册全局组件
  Vue.component('message-global', {
    template: '<div>全局注册的组件</div>',
    data:()=>{
      return {}
    }
  });
// 用来继承的全局组件
  let ComponentA = {
    template: '<div>使用继承注册的全局组件</div>',
    data:()=>{
      return {}
    }
  }
// 返回组件构造器
let MyComponent = Vue.component('message-global')
  console.log('返回组件构造器', MyComponent);
// 使用继承注册全局组件
  Vue.component('messageA', Vue.extend(ComponentA));

// 注册或获取全局过滤器
  Vue.filter('my-filter', function (value) {
    // 返回处理后的值
  })
  // 获取已注册的过滤器
  var globalFilter = Vue.filter('my-filter')

// 获取更新后的dom
  Vue.nextTick(function () {
    // DOM 更新了
  })
// 向响应式对象中添加一个 property，并确保这个新 property 同样是响应式的，且触发视图更新。
  let objarr = []
  let keyorindex = 0
  let value  = '222'
  Vue.set(objarr,keyorindex,value)
  Vue.set(objarr,1,value)
  Vue.delete(objarr,keyorindex)
  console.log('sss',objarr);

// Vue.observable( object )
  // 让一个对象可响应。Vue 内部会用它来处理 data 函数返回的对象。
  // 返回的对象可以直接用于渲染函数和计算属性内，并且会在发生变更时触发相应的更新
  // 也可以作为最小化的跨组件状态存储器，用于简单的场景：
  // 参考https://cn.vuejs.org/v2/guide/reactivity.html 深入响应原理
  const state = Vue.observable({ count: 0 })
  const Demo = {
    render(h) {
      return h('button', {
        on: { click: () => { state.count++ }}
      }, `count is: ${state.count}`)
    }
  }

  ////////////////////////////////////////////////////////////////////////////////////
  // 渲染到根节点和局部api
  ////////////////////////////////////////////////////////////////////////////////////
  let vmdata = {
    name:'李狗蛋',
    objs:{
      classid:'1',
      planid:'2'
    }
  }
  // 声明局部组件
  let limitComponent = {
    template: '<div>局部组件</div>',
    data:()=>{
      return {}
    }
  }
  let vm = new Vue({
    el:'#app',
    // mixins:[mymixin],
    data:vmdata, // 全局data是对象,组件内data是函数
    // 局部自定义指令
    directives: {
      bgtops:{
        inserted: function (el,binding) {
          el.style.backgroundColor = binding.value;
        }
      }
    },
    // 局部组件
    components:{
      'limit-component': limitComponent
    },
    watch: {},
    computed: {},
    filters:{},
    methods:{}
  })
//////////////////////////////////////////////////////////////////////////
// vue 实例属性
//////////////////////////////////////////////////////////////////////////
  // vue 实例
  console.log('vm实例_+_+_+_+_+_+_',vm);
  console.log(vm.$root); // 当前组件树的根 Vue 实例 , 如果当前实例没有父实例，此实例将会是其自己
  console.log(vm.$el === document.getElementById('app'));// -> true
  console.log(vm.$data === vmdata);// -> true
  console.log(vm.name === vmdata.name, vmdata.name);// -> true 李狗蛋
  console.log(vm.$refs);// -> ref_global
  console.log(vm.$parent) // 父实例，如果当前实例有的话
  console.log(vm.$children) // 当前实例的直接子组件。需要注意 $children 并不保证顺序，也不是响应式的
  console.log(vm.$props) // 当前组件接收到的 props 对象
  console.log(vm.$listeners) // 包含了父作用域中的不含 .native 修饰器的v-on 事件监听器。可以通过 v-on="$listeners" 传入内部组件.在创建更高层次的组件时非常有用
  console.log(vm.$attrs) // 通过v-bind="$attrs" 传入内部组件
  console.log(vm.$slots) // 请注意插槽不是响应性的,在使用渲染函数书写一个组件时，访问 vm.$slots 最有帮助.例如：v-slot:foo 中的内容将会在 vm.$slots.foo 中被找
  console.log(vm.$scopedSlots) // 访问作用域插槽,在使用渲染函数开发一个组件时特别有用
  console.log(vm.$isServer); // ->false 判断当前vue实例是否运行于服务器
  console.log(vm.$options); // 用于当前 Vue 实例的初始化选项。需要在选项中包含自定义 property 时会有用处：
  // new Vue({
  //   customOption: 'foo',
  //   created: function () {
  //     console.log(this.$options.customOption) // => 'foo'
  //   }
  // })
////////////////////////////////////////////////////////////////////////////////////
// vue 方法数据
////////////////////////////////////////////////////////////////////////////////////
vm.$watch('objs.classid', function(news,olds){
  console.log(news,olds);
})
vm.$set(vm.objs,'classid','pink');
vm.$delete(vm.objs,1);
console.log(vm.objs);
// 	vm.$emit 触发当前实例上的事件。附加参数都会传给监听器回调
// 	vm.$on 监听当前实例上的自定义事件,由 vm.$emit 触发
// 	vm.$once 监听一个自定义事件，但是只触发一次,随即移除
// 	vm.$off 移除自定义事件监听器
  vm.$emit('test', 'hi')
  vm.$on('test', function (msg) { console.log(msg) })
  vm.$once('test', function (msg) { console.log(msg) })
  vm.$off('test')

////////////////////////////////////////////////////////////////////////////////////
// vue 生命周期
////////////////////////////////////////////////////////////////////////////////////
// vm.$mount 可以使用 vm.$mount() 手动地挂载一个未挂载的实例
  // 	如果 Vue 实例在实例化时没有收到 el 选项，则它处于“未挂载”状态，没有关联的 DOM 元素。
  let ComponentB = {
    template: '<div>mount生命周期挂载到rootapi根结点的组件</div>',
    data:()=>{
      return {}
    }
  }
  let projects = Vue.component('messageB', Vue.extend(ComponentB));
  new projects().$mount('.rootApi');

// vm.$forceUpdate 迫使 Vue 实例重新渲染。注意它仅仅影响实例本身和插入插槽内容的子组件，而不是所有子组件。
  vm.$forceUpdate()
// vm.$nextTick 将回调延迟到下次 DOM 更新循环之后执行。在修改数据之后立即使用它，然后等待 DOM 更新
// 它跟全局方法 Vue.nextTick 一样，不同的是回调的 this 自动绑定到调用它的实例上。
  vm.$nextTick(()=>{
    
  })
  // 	vm.$destroy 完全销毁一个实例。清理它与其它实例的连接，解绑它的全部指令及事件监听器。
  vm.$destroy()

</script>
</body>
</html>